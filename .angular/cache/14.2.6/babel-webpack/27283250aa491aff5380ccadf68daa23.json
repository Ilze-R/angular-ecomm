{"ast":null,"code":"'use strict'; // based on https://github.com/bestiejs/punycode.js/blob/master/punycode.js\n\nvar uncurryThis = require('../internals/function-uncurry-this');\n\nvar maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1\n\nvar base = 36;\nvar tMin = 1;\nvar tMax = 26;\nvar skew = 38;\nvar damp = 700;\nvar initialBias = 72;\nvar initialN = 128; // 0x80\n\nvar delimiter = '-'; // '\\x2D'\n\nvar regexNonASCII = /[^\\0-\\u007E]/; // non-ASCII chars\n\nvar regexSeparators = /[.\\u3002\\uFF0E\\uFF61]/g; // RFC 3490 separators\n\nvar OVERFLOW_ERROR = 'Overflow: input needs wider integers to process';\nvar baseMinusTMin = base - tMin;\nvar $RangeError = RangeError;\nvar exec = uncurryThis(regexSeparators.exec);\nvar floor = Math.floor;\nvar fromCharCode = String.fromCharCode;\nvar charCodeAt = uncurryThis(''.charCodeAt);\nvar join = uncurryThis([].join);\nvar push = uncurryThis([].push);\nvar replace = uncurryThis(''.replace);\nvar split = uncurryThis(''.split);\nvar toLowerCase = uncurryThis(''.toLowerCase);\n/**\n * Creates an array containing the numeric code points of each Unicode\n * character in the string. While JavaScript uses UCS-2 internally,\n * this function will convert a pair of surrogate halves (each of which\n * UCS-2 exposes as separate characters) into a single code point,\n * matching UTF-16.\n */\n\nvar ucs2decode = function (string) {\n  var output = [];\n  var counter = 0;\n  var length = string.length;\n\n  while (counter < length) {\n    var value = charCodeAt(string, counter++);\n\n    if (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n      // It's a high surrogate, and there is a next character.\n      var extra = charCodeAt(string, counter++);\n\n      if ((extra & 0xFC00) == 0xDC00) {\n        // Low surrogate.\n        push(output, ((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n      } else {\n        // It's an unmatched surrogate; only append this code unit, in case the\n        // next code unit is the high surrogate of a surrogate pair.\n        push(output, value);\n        counter--;\n      }\n    } else {\n      push(output, value);\n    }\n  }\n\n  return output;\n};\n/**\n * Converts a digit/integer into a basic code point.\n */\n\n\nvar digitToBasic = function (digit) {\n  //  0..25 map to ASCII a..z or A..Z\n  // 26..35 map to ASCII 0..9\n  return digit + 22 + 75 * (digit < 26);\n};\n/**\n * Bias adaptation function as per section 3.4 of RFC 3492.\n * https://tools.ietf.org/html/rfc3492#section-3.4\n */\n\n\nvar adapt = function (delta, numPoints, firstTime) {\n  var k = 0;\n  delta = firstTime ? floor(delta / damp) : delta >> 1;\n  delta += floor(delta / numPoints);\n\n  while (delta > baseMinusTMin * tMax >> 1) {\n    delta = floor(delta / baseMinusTMin);\n    k += base;\n  }\n\n  return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n};\n/**\n * Converts a string of Unicode symbols (e.g. a domain name label) to a\n * Punycode string of ASCII-only symbols.\n */\n\n\nvar encode = function (input) {\n  var output = []; // Convert the input in UCS-2 to an array of Unicode code points.\n\n  input = ucs2decode(input); // Cache the length.\n\n  var inputLength = input.length; // Initialize the state.\n\n  var n = initialN;\n  var delta = 0;\n  var bias = initialBias;\n  var i, currentValue; // Handle the basic code points.\n\n  for (i = 0; i < input.length; i++) {\n    currentValue = input[i];\n\n    if (currentValue < 0x80) {\n      push(output, fromCharCode(currentValue));\n    }\n  }\n\n  var basicLength = output.length; // number of basic code points.\n\n  var handledCPCount = basicLength; // number of code points that have been handled;\n  // Finish the basic string with a delimiter unless it's empty.\n\n  if (basicLength) {\n    push(output, delimiter);\n  } // Main encoding loop:\n\n\n  while (handledCPCount < inputLength) {\n    // All non-basic code points < n have been handled already. Find the next larger one:\n    var m = maxInt;\n\n    for (i = 0; i < input.length; i++) {\n      currentValue = input[i];\n\n      if (currentValue >= n && currentValue < m) {\n        m = currentValue;\n      }\n    } // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>, but guard against overflow.\n\n\n    var handledCPCountPlusOne = handledCPCount + 1;\n\n    if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n      throw $RangeError(OVERFLOW_ERROR);\n    }\n\n    delta += (m - n) * handledCPCountPlusOne;\n    n = m;\n\n    for (i = 0; i < input.length; i++) {\n      currentValue = input[i];\n\n      if (currentValue < n && ++delta > maxInt) {\n        throw $RangeError(OVERFLOW_ERROR);\n      }\n\n      if (currentValue == n) {\n        // Represent delta as a generalized variable-length integer.\n        var q = delta;\n        var k = base;\n\n        while (true) {\n          var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n          if (q < t) break;\n          var qMinusT = q - t;\n          var baseMinusT = base - t;\n          push(output, fromCharCode(digitToBasic(t + qMinusT % baseMinusT)));\n          q = floor(qMinusT / baseMinusT);\n          k += base;\n        }\n\n        push(output, fromCharCode(digitToBasic(q)));\n        bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n        delta = 0;\n        handledCPCount++;\n      }\n    }\n\n    delta++;\n    n++;\n  }\n\n  return join(output, '');\n};\n\nmodule.exports = function (input) {\n  var encoded = [];\n  var labels = split(replace(toLowerCase(input), regexSeparators, '\\u002E'), '.');\n  var i, label;\n\n  for (i = 0; i < labels.length; i++) {\n    label = labels[i];\n    push(encoded, exec(regexNonASCII, label) ? 'xn--' + encode(label) : label);\n  }\n\n  return join(encoded, '.');\n};","map":{"version":3,"sources":["/Users/i/Desktop/angular/ang-full-ecom/03-frontend/angular-ecommerce/node_modules/core-js-pure/internals/string-punycode-to-ascii.js"],"names":["uncurryThis","require","maxInt","base","tMin","tMax","skew","damp","initialBias","initialN","delimiter","regexNonASCII","regexSeparators","OVERFLOW_ERROR","baseMinusTMin","$RangeError","RangeError","exec","floor","Math","fromCharCode","String","charCodeAt","join","push","replace","split","toLowerCase","ucs2decode","string","output","counter","length","value","extra","digitToBasic","digit","adapt","delta","numPoints","firstTime","k","encode","input","inputLength","n","bias","i","currentValue","basicLength","handledCPCount","m","handledCPCountPlusOne","q","t","qMinusT","baseMinusT","module","exports","encoded","labels","label"],"mappings":"AAAA,a,CACA;;AACA,IAAIA,WAAW,GAAGC,OAAO,CAAC,oCAAD,CAAzB;;AAEA,IAAIC,MAAM,GAAG,UAAb,C,CAAyB;;AACzB,IAAIC,IAAI,GAAG,EAAX;AACA,IAAIC,IAAI,GAAG,CAAX;AACA,IAAIC,IAAI,GAAG,EAAX;AACA,IAAIC,IAAI,GAAG,EAAX;AACA,IAAIC,IAAI,GAAG,GAAX;AACA,IAAIC,WAAW,GAAG,EAAlB;AACA,IAAIC,QAAQ,GAAG,GAAf,C,CAAoB;;AACpB,IAAIC,SAAS,GAAG,GAAhB,C,CAAqB;;AACrB,IAAIC,aAAa,GAAG,cAApB,C,CAAoC;;AACpC,IAAIC,eAAe,GAAG,wBAAtB,C,CAAgD;;AAChD,IAAIC,cAAc,GAAG,iDAArB;AACA,IAAIC,aAAa,GAAGX,IAAI,GAAGC,IAA3B;AAEA,IAAIW,WAAW,GAAGC,UAAlB;AACA,IAAIC,IAAI,GAAGjB,WAAW,CAACY,eAAe,CAACK,IAAjB,CAAtB;AACA,IAAIC,KAAK,GAAGC,IAAI,CAACD,KAAjB;AACA,IAAIE,YAAY,GAAGC,MAAM,CAACD,YAA1B;AACA,IAAIE,UAAU,GAAGtB,WAAW,CAAC,GAAGsB,UAAJ,CAA5B;AACA,IAAIC,IAAI,GAAGvB,WAAW,CAAC,GAAGuB,IAAJ,CAAtB;AACA,IAAIC,IAAI,GAAGxB,WAAW,CAAC,GAAGwB,IAAJ,CAAtB;AACA,IAAIC,OAAO,GAAGzB,WAAW,CAAC,GAAGyB,OAAJ,CAAzB;AACA,IAAIC,KAAK,GAAG1B,WAAW,CAAC,GAAG0B,KAAJ,CAAvB;AACA,IAAIC,WAAW,GAAG3B,WAAW,CAAC,GAAG2B,WAAJ,CAA7B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,IAAIC,UAAU,GAAG,UAAUC,MAAV,EAAkB;AACjC,MAAIC,MAAM,GAAG,EAAb;AACA,MAAIC,OAAO,GAAG,CAAd;AACA,MAAIC,MAAM,GAAGH,MAAM,CAACG,MAApB;;AACA,SAAOD,OAAO,GAAGC,MAAjB,EAAyB;AACvB,QAAIC,KAAK,GAAGX,UAAU,CAACO,MAAD,EAASE,OAAO,EAAhB,CAAtB;;AACA,QAAIE,KAAK,IAAI,MAAT,IAAmBA,KAAK,IAAI,MAA5B,IAAsCF,OAAO,GAAGC,MAApD,EAA4D;AAC1D;AACA,UAAIE,KAAK,GAAGZ,UAAU,CAACO,MAAD,EAASE,OAAO,EAAhB,CAAtB;;AACA,UAAI,CAACG,KAAK,GAAG,MAAT,KAAoB,MAAxB,EAAgC;AAAE;AAChCV,QAAAA,IAAI,CAACM,MAAD,EAAS,CAAC,CAACG,KAAK,GAAG,KAAT,KAAmB,EAApB,KAA2BC,KAAK,GAAG,KAAnC,IAA4C,OAArD,CAAJ;AACD,OAFD,MAEO;AACL;AACA;AACAV,QAAAA,IAAI,CAACM,MAAD,EAASG,KAAT,CAAJ;AACAF,QAAAA,OAAO;AACR;AACF,KAXD,MAWO;AACLP,MAAAA,IAAI,CAACM,MAAD,EAASG,KAAT,CAAJ;AACD;AACF;;AACD,SAAOH,MAAP;AACD,CAtBD;AAwBA;AACA;AACA;;;AACA,IAAIK,YAAY,GAAG,UAAUC,KAAV,EAAiB;AAClC;AACA;AACA,SAAOA,KAAK,GAAG,EAAR,GAAa,MAAMA,KAAK,GAAG,EAAd,CAApB;AACD,CAJD;AAMA;AACA;AACA;AACA;;;AACA,IAAIC,KAAK,GAAG,UAAUC,KAAV,EAAiBC,SAAjB,EAA4BC,SAA5B,EAAuC;AACjD,MAAIC,CAAC,GAAG,CAAR;AACAH,EAAAA,KAAK,GAAGE,SAAS,GAAGtB,KAAK,CAACoB,KAAK,GAAG/B,IAAT,CAAR,GAAyB+B,KAAK,IAAI,CAAnD;AACAA,EAAAA,KAAK,IAAIpB,KAAK,CAACoB,KAAK,GAAGC,SAAT,CAAd;;AACA,SAAOD,KAAK,GAAGxB,aAAa,GAAGT,IAAhB,IAAwB,CAAvC,EAA0C;AACxCiC,IAAAA,KAAK,GAAGpB,KAAK,CAACoB,KAAK,GAAGxB,aAAT,CAAb;AACA2B,IAAAA,CAAC,IAAItC,IAAL;AACD;;AACD,SAAOe,KAAK,CAACuB,CAAC,GAAG,CAAC3B,aAAa,GAAG,CAAjB,IAAsBwB,KAAtB,IAA+BA,KAAK,GAAGhC,IAAvC,CAAL,CAAZ;AACD,CATD;AAWA;AACA;AACA;AACA;;;AACA,IAAIoC,MAAM,GAAG,UAAUC,KAAV,EAAiB;AAC5B,MAAIb,MAAM,GAAG,EAAb,CAD4B,CAG5B;;AACAa,EAAAA,KAAK,GAAGf,UAAU,CAACe,KAAD,CAAlB,CAJ4B,CAM5B;;AACA,MAAIC,WAAW,GAAGD,KAAK,CAACX,MAAxB,CAP4B,CAS5B;;AACA,MAAIa,CAAC,GAAGpC,QAAR;AACA,MAAI6B,KAAK,GAAG,CAAZ;AACA,MAAIQ,IAAI,GAAGtC,WAAX;AACA,MAAIuC,CAAJ,EAAOC,YAAP,CAb4B,CAe5B;;AACA,OAAKD,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGJ,KAAK,CAACX,MAAtB,EAA8Be,CAAC,EAA/B,EAAmC;AACjCC,IAAAA,YAAY,GAAGL,KAAK,CAACI,CAAD,CAApB;;AACA,QAAIC,YAAY,GAAG,IAAnB,EAAyB;AACvBxB,MAAAA,IAAI,CAACM,MAAD,EAASV,YAAY,CAAC4B,YAAD,CAArB,CAAJ;AACD;AACF;;AAED,MAAIC,WAAW,GAAGnB,MAAM,CAACE,MAAzB,CAvB4B,CAuBK;;AACjC,MAAIkB,cAAc,GAAGD,WAArB,CAxB4B,CAwBM;AAElC;;AACA,MAAIA,WAAJ,EAAiB;AACfzB,IAAAA,IAAI,CAACM,MAAD,EAASpB,SAAT,CAAJ;AACD,GA7B2B,CA+B5B;;;AACA,SAAOwC,cAAc,GAAGN,WAAxB,EAAqC;AACnC;AACA,QAAIO,CAAC,GAAGjD,MAAR;;AACA,SAAK6C,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGJ,KAAK,CAACX,MAAtB,EAA8Be,CAAC,EAA/B,EAAmC;AACjCC,MAAAA,YAAY,GAAGL,KAAK,CAACI,CAAD,CAApB;;AACA,UAAIC,YAAY,IAAIH,CAAhB,IAAqBG,YAAY,GAAGG,CAAxC,EAA2C;AACzCA,QAAAA,CAAC,GAAGH,YAAJ;AACD;AACF,KARkC,CAUnC;;;AACA,QAAII,qBAAqB,GAAGF,cAAc,GAAG,CAA7C;;AACA,QAAIC,CAAC,GAAGN,CAAJ,GAAQ3B,KAAK,CAAC,CAAChB,MAAM,GAAGoC,KAAV,IAAmBc,qBAApB,CAAjB,EAA6D;AAC3D,YAAMrC,WAAW,CAACF,cAAD,CAAjB;AACD;;AAEDyB,IAAAA,KAAK,IAAI,CAACa,CAAC,GAAGN,CAAL,IAAUO,qBAAnB;AACAP,IAAAA,CAAC,GAAGM,CAAJ;;AAEA,SAAKJ,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGJ,KAAK,CAACX,MAAtB,EAA8Be,CAAC,EAA/B,EAAmC;AACjCC,MAAAA,YAAY,GAAGL,KAAK,CAACI,CAAD,CAApB;;AACA,UAAIC,YAAY,GAAGH,CAAf,IAAoB,EAAEP,KAAF,GAAUpC,MAAlC,EAA0C;AACxC,cAAMa,WAAW,CAACF,cAAD,CAAjB;AACD;;AACD,UAAImC,YAAY,IAAIH,CAApB,EAAuB;AACrB;AACA,YAAIQ,CAAC,GAAGf,KAAR;AACA,YAAIG,CAAC,GAAGtC,IAAR;;AACA,eAAO,IAAP,EAAa;AACX,cAAImD,CAAC,GAAGb,CAAC,IAAIK,IAAL,GAAY1C,IAAZ,GAAoBqC,CAAC,IAAIK,IAAI,GAAGzC,IAAZ,GAAmBA,IAAnB,GAA0BoC,CAAC,GAAGK,IAA1D;AACA,cAAIO,CAAC,GAAGC,CAAR,EAAW;AACX,cAAIC,OAAO,GAAGF,CAAC,GAAGC,CAAlB;AACA,cAAIE,UAAU,GAAGrD,IAAI,GAAGmD,CAAxB;AACA9B,UAAAA,IAAI,CAACM,MAAD,EAASV,YAAY,CAACe,YAAY,CAACmB,CAAC,GAAGC,OAAO,GAAGC,UAAf,CAAb,CAArB,CAAJ;AACAH,UAAAA,CAAC,GAAGnC,KAAK,CAACqC,OAAO,GAAGC,UAAX,CAAT;AACAf,UAAAA,CAAC,IAAItC,IAAL;AACD;;AAEDqB,QAAAA,IAAI,CAACM,MAAD,EAASV,YAAY,CAACe,YAAY,CAACkB,CAAD,CAAb,CAArB,CAAJ;AACAP,QAAAA,IAAI,GAAGT,KAAK,CAACC,KAAD,EAAQc,qBAAR,EAA+BF,cAAc,IAAID,WAAjD,CAAZ;AACAX,QAAAA,KAAK,GAAG,CAAR;AACAY,QAAAA,cAAc;AACf;AACF;;AAEDZ,IAAAA,KAAK;AACLO,IAAAA,CAAC;AACF;;AACD,SAAOtB,IAAI,CAACO,MAAD,EAAS,EAAT,CAAX;AACD,CAjFD;;AAmFA2B,MAAM,CAACC,OAAP,GAAiB,UAAUf,KAAV,EAAiB;AAChC,MAAIgB,OAAO,GAAG,EAAd;AACA,MAAIC,MAAM,GAAGlC,KAAK,CAACD,OAAO,CAACE,WAAW,CAACgB,KAAD,CAAZ,EAAqB/B,eAArB,EAAsC,QAAtC,CAAR,EAAyD,GAAzD,CAAlB;AACA,MAAImC,CAAJ,EAAOc,KAAP;;AACA,OAAKd,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGa,MAAM,CAAC5B,MAAvB,EAA+Be,CAAC,EAAhC,EAAoC;AAClCc,IAAAA,KAAK,GAAGD,MAAM,CAACb,CAAD,CAAd;AACAvB,IAAAA,IAAI,CAACmC,OAAD,EAAU1C,IAAI,CAACN,aAAD,EAAgBkD,KAAhB,CAAJ,GAA6B,SAASnB,MAAM,CAACmB,KAAD,CAA5C,GAAsDA,KAAhE,CAAJ;AACD;;AACD,SAAOtC,IAAI,CAACoC,OAAD,EAAU,GAAV,CAAX;AACD,CATD","sourcesContent":["'use strict';\n// based on https://github.com/bestiejs/punycode.js/blob/master/punycode.js\nvar uncurryThis = require('../internals/function-uncurry-this');\n\nvar maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1\nvar base = 36;\nvar tMin = 1;\nvar tMax = 26;\nvar skew = 38;\nvar damp = 700;\nvar initialBias = 72;\nvar initialN = 128; // 0x80\nvar delimiter = '-'; // '\\x2D'\nvar regexNonASCII = /[^\\0-\\u007E]/; // non-ASCII chars\nvar regexSeparators = /[.\\u3002\\uFF0E\\uFF61]/g; // RFC 3490 separators\nvar OVERFLOW_ERROR = 'Overflow: input needs wider integers to process';\nvar baseMinusTMin = base - tMin;\n\nvar $RangeError = RangeError;\nvar exec = uncurryThis(regexSeparators.exec);\nvar floor = Math.floor;\nvar fromCharCode = String.fromCharCode;\nvar charCodeAt = uncurryThis(''.charCodeAt);\nvar join = uncurryThis([].join);\nvar push = uncurryThis([].push);\nvar replace = uncurryThis(''.replace);\nvar split = uncurryThis(''.split);\nvar toLowerCase = uncurryThis(''.toLowerCase);\n\n/**\n * Creates an array containing the numeric code points of each Unicode\n * character in the string. While JavaScript uses UCS-2 internally,\n * this function will convert a pair of surrogate halves (each of which\n * UCS-2 exposes as separate characters) into a single code point,\n * matching UTF-16.\n */\nvar ucs2decode = function (string) {\n  var output = [];\n  var counter = 0;\n  var length = string.length;\n  while (counter < length) {\n    var value = charCodeAt(string, counter++);\n    if (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n      // It's a high surrogate, and there is a next character.\n      var extra = charCodeAt(string, counter++);\n      if ((extra & 0xFC00) == 0xDC00) { // Low surrogate.\n        push(output, ((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n      } else {\n        // It's an unmatched surrogate; only append this code unit, in case the\n        // next code unit is the high surrogate of a surrogate pair.\n        push(output, value);\n        counter--;\n      }\n    } else {\n      push(output, value);\n    }\n  }\n  return output;\n};\n\n/**\n * Converts a digit/integer into a basic code point.\n */\nvar digitToBasic = function (digit) {\n  //  0..25 map to ASCII a..z or A..Z\n  // 26..35 map to ASCII 0..9\n  return digit + 22 + 75 * (digit < 26);\n};\n\n/**\n * Bias adaptation function as per section 3.4 of RFC 3492.\n * https://tools.ietf.org/html/rfc3492#section-3.4\n */\nvar adapt = function (delta, numPoints, firstTime) {\n  var k = 0;\n  delta = firstTime ? floor(delta / damp) : delta >> 1;\n  delta += floor(delta / numPoints);\n  while (delta > baseMinusTMin * tMax >> 1) {\n    delta = floor(delta / baseMinusTMin);\n    k += base;\n  }\n  return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n};\n\n/**\n * Converts a string of Unicode symbols (e.g. a domain name label) to a\n * Punycode string of ASCII-only symbols.\n */\nvar encode = function (input) {\n  var output = [];\n\n  // Convert the input in UCS-2 to an array of Unicode code points.\n  input = ucs2decode(input);\n\n  // Cache the length.\n  var inputLength = input.length;\n\n  // Initialize the state.\n  var n = initialN;\n  var delta = 0;\n  var bias = initialBias;\n  var i, currentValue;\n\n  // Handle the basic code points.\n  for (i = 0; i < input.length; i++) {\n    currentValue = input[i];\n    if (currentValue < 0x80) {\n      push(output, fromCharCode(currentValue));\n    }\n  }\n\n  var basicLength = output.length; // number of basic code points.\n  var handledCPCount = basicLength; // number of code points that have been handled;\n\n  // Finish the basic string with a delimiter unless it's empty.\n  if (basicLength) {\n    push(output, delimiter);\n  }\n\n  // Main encoding loop:\n  while (handledCPCount < inputLength) {\n    // All non-basic code points < n have been handled already. Find the next larger one:\n    var m = maxInt;\n    for (i = 0; i < input.length; i++) {\n      currentValue = input[i];\n      if (currentValue >= n && currentValue < m) {\n        m = currentValue;\n      }\n    }\n\n    // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>, but guard against overflow.\n    var handledCPCountPlusOne = handledCPCount + 1;\n    if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n      throw $RangeError(OVERFLOW_ERROR);\n    }\n\n    delta += (m - n) * handledCPCountPlusOne;\n    n = m;\n\n    for (i = 0; i < input.length; i++) {\n      currentValue = input[i];\n      if (currentValue < n && ++delta > maxInt) {\n        throw $RangeError(OVERFLOW_ERROR);\n      }\n      if (currentValue == n) {\n        // Represent delta as a generalized variable-length integer.\n        var q = delta;\n        var k = base;\n        while (true) {\n          var t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n          if (q < t) break;\n          var qMinusT = q - t;\n          var baseMinusT = base - t;\n          push(output, fromCharCode(digitToBasic(t + qMinusT % baseMinusT)));\n          q = floor(qMinusT / baseMinusT);\n          k += base;\n        }\n\n        push(output, fromCharCode(digitToBasic(q)));\n        bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n        delta = 0;\n        handledCPCount++;\n      }\n    }\n\n    delta++;\n    n++;\n  }\n  return join(output, '');\n};\n\nmodule.exports = function (input) {\n  var encoded = [];\n  var labels = split(replace(toLowerCase(input), regexSeparators, '\\u002E'), '.');\n  var i, label;\n  for (i = 0; i < labels.length; i++) {\n    label = labels[i];\n    push(encoded, exec(regexNonASCII, label) ? 'xn--' + encode(label) : label);\n  }\n  return join(encoded, '.');\n};\n"]},"metadata":{},"sourceType":"script"}